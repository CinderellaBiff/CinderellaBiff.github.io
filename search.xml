<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>编译原理：语法分析</title>
      <link href="/2021/06/13/compiler/"/>
      <url>/2021/06/13/compiler/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍编译原理的第四章：语法分析</p><h3 id="语法分析器的作用"><a href="#语法分析器的作用" class="headerlink" title="语法分析器的作用"></a>语法分析器的作用</h3><p>编译器中常用的方法可以分为自顶向下的和自底向上的。</p><p>自顶向下的方法从语法分析树的顶部（根节点）开始向底部（叶子节点）构造语法分析树；</p><p>而自底向上的方法则从叶子节点开始，逐渐向根节点方向构造。</p><p>在两种分析方法中，语法分析器的输入<strong>总是按照自左向右的方式被扫描</strong>，每次扫描一个符号。</p><p>最高效的自顶向下方法和自底向上方法只能处理某些文法子类，但其中的某些子类，特别是<strong>LL和LR文法</strong>，其表达能力已经足以描述现代程序设计语言的大部分语法构造了。</p><p>自顶向下方法——用自顶向下方法处理LL文法——最左推导</p><p>自底向上方法——用自底向上方法处理LR文法——最右推导</p><p>这两种文法足以描述大部分现代程序设计语言。（这两种文法都是上下文无关文法）</p><h3 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h3><p>一个上下文无关文法（简称文法）由终结符号、非终结符号、一个开始符号和一组产生式组成。</p><h3 id="自顶向下的语法分析"><a href="#自顶向下的语法分析" class="headerlink" title="自顶向下的语法分析"></a>自顶向下的语法分析</h3><p>自顶向下语法分析可以被看作是为输入串构造语法分析树的问题，他<strong>从语法分析树的根节点开始</strong>，按照先根次序（深度优先地）创建这棵语法分析树的各个结点。自顶向下语法分析也可以被看作寻找输入串的<strong>最左推导</strong>的过程。</p><p>预测分析技术是递归下降分析技术的一个特例，它不需要进行回溯。</p><p>预测分析技术通过在输入中向前看固定多个符号（一般只向前看一个就够了）来选择正确的A产生式。</p><p>可以采用预测分析技术，构造出预测分析其的文法称为LL(k)文法类，我们只讨论<strong>LL(1)文法类</strong>。根据一个文法的FIRST和FOLLOW集合，可以构造出“预测分析表”，<strong>“预测分析表”说明了如何在自顶向下语法分析过程中选择产生式</strong>。这些集合<u>也可以用于自底向上语法分析</u>。</p><h3 id="FIRST和FOLLOW"><a href="#FIRST和FOLLOW" class="headerlink" title="FIRST和FOLLOW"></a>FIRST和FOLLOW</h3><p><u>自顶向下和自底向上语法分析器的构造可以使用和文法G相关的两个函数FIRST和FOLLOW来实现</u>。在自顶向下语法分析过程中，FIRST和FOLLOW使得我们可以根据下一个输入符号来选择应用哪个产生式。</p><p><strong>FIRST(α)<strong>被定义为</strong>可从α推导得到的串的<u>首符号</u>的集合</strong>，其中α是任意的文法符号串。如果<u>α经过零次或多次推导得到<strong>ϵ</strong>，那么ϵ也在FIRST(a)中</u>。比如A→cγ，c在FIRST(A)中</p><p>注意这里哈，只要α能推出ϵ，无论经过多少步，那么ϵ就在FIRST(A)中</p><p>先简单介绍一下如何在预测分析中使用FIRST。考虑两个A产生式A→α|β，其中FIRST(α)和FIRST(β)是不相交的集合。那么我们只需查看下一个输入符号a，就可以在这两个A产生式中进行选择。因为a只能出现在FIRST(α)或FIRST(β)中，但不能同时出现在两个集合中。比如，如果a在FIRST(β)中，就选择A→β。</p><p>对于非终结符号A，<strong>FOLLOW(A)被定义为可能在某些句型中紧跟在A右边的<u>终结符号</u>的集合</strong>。也就是说，如果存在形如S<em>→αAaβ的推导，那么终结符号a就在FOLLOW(A)中，其中α和β是文法符号串。请注意，在这个推到的某个阶段，A和a之间可能存在一些文法符号，但如果这样，这些符号会推导得到ϵ并小时。另外，如果A是某些句型的最右符号，那么$也在FOLLOW(A)中。*</em>$**是一个特殊的结束标记的符号。</p><p>计算<strong>各个文法符号X</strong>的FIRST(X)时，不断应用下列规则，直到再没有新的终结符号或ϵ可以被加入到任何FIRST集合中为止。</p><ol><li>如果X是一个终结符号，那么FIRST(X)=X</li><li>如果X是一个非终结符号，且X→Y1Y2……Yk是一个产生式，其中k≥1，那么如果对于某个i，a在FIRST(Yi)中且ϵ在所有的FIRST(Y1)、FIRST(Y2)、……、FIRST(Yi-1)中，那就把a加入到FIRST(X)中。也就是说，Y1Y2……Yi-1*→ϵ。如果对于所有的j=1，2，……，k，ϵ在FIRST(Yj)中，那么将ϵ加入到FIRST(X)中。比如，FIRST(Y1)中的所有符号一定在FIRST(X)中。如果Y1不能推导出ϵ，那么我们就不会再向FIRST(X)中加入任何符号，但是如果Y1经过0次或多次推导能得到ϵ，那么我们就加上FIRST(Y2)，以此类推。</li><li>如果X→ϵ是一个产生式，那么将ϵ加入FIRST(X)中</li></ol><p>现在，我们可以按照如下方式计算任何串X1X2……Xn的FIRST集合，向FIRST(X1X2……Xn)加入FIRST(X1)中所有的非ϵ符号。如果ϵ在FIRST(X1)中，再加上FIRST(X2)中的所有非ϵ符号，依次类推。最后，如果对于所有的i，ϵ都在FIRST(Xi)中，那么将ϵ加入到FIRST(X1X2……Xn)中。</p><p>计算<strong>所有非终结符号</strong>的FOLLOW(A)集合时，不断应用下面的规则，直到再没有新的终结符号可以被加入到任意FOLLOW集合中为止：</p><ul><li>将$放到FOLLOW(S)中，其中S是开始符号，而$是输入右端的结束标记</li><li>如果存在一个产生式A→αBβ，那么FIRST(β)中除ϵ之外的所有符号都在FOLLOW(B)中</li><li>如果存在一个产生式A→αB，或存在产生式A→αBβ且FIRST(β)包含ϵ，那么FOLLOW(A)中的所有符号都在FOLLOW(B)中。</li></ul><h3 id="非递归的预测分析"><a href="#非递归的预测分析" class="headerlink" title="非递归的预测分析"></a>非递归的预测分析</h3><p>我们可以构造出一个非递归的预测分析器，它显式地维护一个栈结构，而不是通过递归调用的方式隐式地维护栈。这样的语法分析器可以模拟最左推导的过程。</p><p>语法分析器有一个程序控制，该程序考虑栈顶符号X和当前输入符号a。如果X是一个非终结符号，该分析器查询分析表M中的条目M[X,a]来选择一个X产生式。否则，它检查终结符号X和当前输入符号a是否匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程概念</title>
      <link href="/2021/06/13/software-engineer/"/>
      <url>/2021/06/13/software-engineer/</url>
      
        <content type="html"><![CDATA[<p>本文将介绍软件工程的基本概念。</p><h2 id="软件的基本概念"><a href="#软件的基本概念" class="headerlink" title="软件的基本概念"></a>软件的基本概念</h2><h3 id="什么是软件"><a href="#什么是软件" class="headerlink" title="什么是软件"></a>什么是软件</h3><p>软件：一组对象或项目所形成的一个配置，由程序、文档和数据等部分构成。</p><ul><li>程序：可被计算机硬件理解并执行的一组指令，提供期望的性能和功能。（程序≠软件）</li><li>数据：程序能正常操纵信息的数据结构。</li><li>文档：与程序开发、维护和使用有关的图文材料。</li></ul><h3 id="软件分类"><a href="#软件分类" class="headerlink" title="软件分类"></a>软件分类</h3><ul><li>应用软件：为满足特定应用领域、不同应用问题之需求的专用软件。如美团外卖、WPS、Web服务软件和服务形态的SaaS软件。</li><li>支撑软件：软件系统的中间层，支撑各种软件的开发、运行与维护的软件。PaaS</li><li>系统软件：最靠近计算机硬件的一层软件——控制和协调计算机即外部设备、支持应用软件开发与运行的软件。Iaas</li></ul><h3 id="软件的四大特征"><a href="#软件的四大特征" class="headerlink" title="软件的四大特征"></a>软件的四大特征</h3><ul><li><p>复杂性</p><p>软件要解决的现实问题通常很复杂，数据、状态、逻辑关系的可能组合导致了软件本身的复杂性。</p><p>软件无法以“制造”的方式被生产，只能采用手工开发方式。</p><p>这是一种人为、抽象化的智能活动（智力密集型），与人的水平密切相关，人类思维的不确定性导致了开发过程的复杂性。</p></li><li><p>不可见性</p><p>尚未完成的软件是看不见的，无法像汽车等产品一样充分呈现其结构，使得人们在沟通上面临极大的困难，难以精确的刻画和度量。</p></li><li><p>易变性</p><p>软件所应用的环境由人群、法规、硬件设备、应用领域等因素汇集而成，而这些因素皆会频繁快速的变化。</p></li><li><p>一致性</p><p>各子系统的接口必须协同一致，而随着时间和环境的演变，要维持这样的一致性通常非常困难。</p></li></ul><h3 id="软件及其开发方式的发展"><a href="#软件及其开发方式的发展" class="headerlink" title="软件及其开发方式的发展"></a>软件及其开发方式的发展</h3><ul><li><p>第一阶段（1950-1960年代）</p><p>软件“简单→复杂”的发展，导致“软件危机”的出现</p></li><li><p>第二阶段（1970年代）</p><p>“软件生命周期”的概念开始形成</p></li><li><p>第三阶段（1980年代）</p><p>开始关注软件的质量度量和管理</p></li><li><p>第四阶段（1990年代-至今）</p><p>软件复用成为关注点</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件工程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
